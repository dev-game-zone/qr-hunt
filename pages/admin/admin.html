<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Scavenger Hunt – Admin Panel</title>
<link rel="stylesheet" href="../../styles/styles.css">
<link rel="icon" type="image/png" href="../../favicon.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
/* ================================
   Admin PIN input - center aligned and uppercase
================================= */
body.admin #adminPin {
  text-align: center;
  text-transform: uppercase;
}

body.admin #adminPin::placeholder {
  text-transform: none;
}

/* ================================
   Tabs & Content
================================= */
#tabs { display: none; }

.tab-content { display: none; padding: 15px 0; }
.tab-content.active { display: block; }

/* Floating Orbs Layer - minimal inline rules (appearance controlled in styles.css) */
#floating-orbs {
  position: fixed;
  top: 50%;
  left: 50%;
  width: 400px;
  height: 300px;
  transform: translate(-50%, -50%);
  pointer-events: none;
  z-index: 9998;
  overflow: visible;
}

/* individual orb visuals (size, padding, shape) are defined in styles.css so they
   can adapt and scale to text; keep minimal positioning helpers here */
#floating-orbs .letter-box { position: absolute; transform-origin: center; }
#floating-orbs .letter-box.winner { z-index: 10001; }

/* Suspense-centering: when an orb is being highlighted during the draw
   it will briefly move toward the center, scale up, then return. We use
   translate/scale transitions so the animation stays on the compositor. */
#floating-orbs .letter-box.suspense-centered {
  transition: transform 260ms cubic-bezier(.2,.9,.2,1), box-shadow 260ms ease;
  z-index: 10000;
  box-shadow: 0 0 30px rgba(255,255,255,0.6);
}

/* Centered (final winner) tweaks - larger scale and a stronger z-index */
#floating-orbs .letter-box.centered {
  transition: transform 450ms cubic-bezier(.2,.9,.2,1), box-shadow 450ms ease, left 450ms ease, top 450ms ease;
  z-index: 10002 !important;
  /* Fix winner in viewport center so it visibly pops out */
  position: fixed !important;
  left: 50% !important;
  top: 50% !important;
  transform: translate(-50%, -50%) scale(1.9) !important;
  pointer-events: none;
}

/* ================================
   Optional Glow Animation for Winner
================================= */
@keyframes winner-glow {
  0% { box-shadow: 0 0 10px #ffcc00; }
  50% { box-shadow: 0 0 25px #ffcc00; }
  100% { box-shadow: 0 0 10px #ffcc00; }
}

#floating-orbs .letter-box.winner.glow {
  animation: winner-glow 1s ease-in-out infinite alternate;
}

/* temporary suspense highlight used during draw countdown */
#floating-orbs .letter-box.suspense {
  box-shadow: 0 0 18px rgba(255,255,255,0.45);
  transform: scale(1.12);
}

/* ================================
   Pop animation (used for tickets/letters)
================================= */
@keyframes pop {
  0% { transform: scale(1); }
  50% { transform: scale(1.25); }
  100% { transform: scale(1); }
}

#countdown-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  pointer-events: none;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 99999;
}

.countdown-number {
  position: absolute;
  font-size: 8rem;
  font-weight: 900;
  color: white;
  text-shadow: 0 0 25px rgba(0,0,0,0.5);
  opacity: 0;
  transform: scale(0.3);
  transition: transform 0.9s ease, opacity 0.9s ease;
}

/* ================================
   Podium for drawn winners
================================= */
#podium { display:flex; justify-content:center; gap:18px; align-items:flex-end; margin-top:18px; }
.podium-place { width:120px; text-align:center; }
.podium-orb { width:120px; height:120px; border-radius:50%; margin:0 auto 8px; display:flex; align-items:center; justify-content:center; font-weight:800; color:#fff; box-shadow:0 6px 18px rgba(0,0,0,0.12); background:rgba(0,0,0,0.06); }
.podium-place .label { font-size:0.9rem; color:#333; }
.podium-place.place1 { transform:translateY(-16px); }
.podium-place.place2 { transform:translateY(0); }
.podium-place.place3 { transform:translateY(6px); }

/* Dim ticket list items that already won */
.ticket.winner { opacity: 0.45; text-decoration: line-through; }
.podium-orb { font-size:1.05rem; }
/* Dim floating orbs that already won */
#floating-orbs .letter-box.won { opacity: 0.45; filter: grayscale(.25); pointer-events: none; }

</style>
</head>

<body class="admin">
<script>
  if (sessionStorage.getItem("access") !== "granted") {
    window.location.href = "../../index.html";
  }
</script>
<main>
  <h2>Admin Panel</h2>
  <p>Secure access required to manage QR codes and run the Tombola.</p>

  <!-- PIN Entry -->
  <div id="pin-section">
    <input type="text" id="adminPin" placeholder="Enter Admin PIN">
    <div class="button-group">
      <button id="verifyPin">Verify</button>
    </div>
    <p id="pinMsg"></p>
  </div>


  <!-- Tabs -->
  <div id="tabs" class="tabs">
    <div class="button-group">
      <button class="tab-button active" data-tab="generator-tab">QR Generator</button>
      <button class="tab-button" data-tab="registration-tab">Registration</button>
      <button class="tab-button" data-tab="tombola-tab">Tombola Admin</button>
      <button class="tab-button" data-tab="orbview-tab">Tombola Draw</button>
    </div>

    <!-- Generator Tab -->
    <div id="generator-tab" class="tab-content active">
      <h3>QR Code Generator</h3>
      <label for="qrId">Enter Code ID (e.g. QR001):</label>
      <input id="qrId" type="text" placeholder="QR001">
      <p />
      <label for="qrLetter">Letter or Word:</label>
      <input id="qrLetter" type="text" placeholder="A">
      <div class="button-group">
        <button id="generate">Generate QR</button>
        <button id="download">Download QR</button>
      </div>
      <div id="qrcode"></div>
      <p id="msg"></p>
      <h3>Current Mappings (Session Only)</h3>
      <table id="mapTable">
        <thead><tr><th>QR Code</th><th>Letter</th></tr></thead>
        <tbody></tbody>
      </table>
      <div class="button-group">
        <button id="export">Export Mapping</button>
      </div>
      <p id="exportMsg"></p>
    </div>

    <!-- Registration Tab -->
    <div id="registration-tab" class="tab-content" style="text-align:center;display:none;">
      <h3>Player Registration</h3>
      <iframe src="../registration/registration.html" title="Player Registration" width="420" height="520" style="border: 1px solid #ccc; border-radius: 12px; box-shadow: 0 2px 12px rgba(0,0,0,0.07);"></iframe>
      <p style="font-size:0.95em;color:#888;margin-top:8px;">Players can register their code here.</p>
    </div>
      <!-- ORB View Tab -->
      <div id="orbview-tab" class="tab-content" style="text-align:center;display:none;">
        <p style="color:#888;font-size:0.95em;">Live view of all registered ORBs.</p>
        <div id="floating-orbs" class="orb-container"></div>
        <div class="button-group">
          <button id="startDraw">Start Draw</button>
        </div>
        <p id="winner-msg"></p>
        <div id="podium" aria-live="polite" aria-atomic="true"></div>
      </div>

      <!-- Tombola Tab -->
      <div id="tombola-tab" class="tab-content">
        <h3>Tombola Draw</h3>
        <p>Registered Codes:</p>
        <textarea id="tombolaCodes" readonly></textarea>
        <div class="button-group">
          <button id="resetTombola">Reset Tombola</button>
        </div>
        <div id="ticket-list"></div>
      </div>
    </div>
  </div>
</main>

<!-- Confetti canvas -->
<canvas id="confetti-canvas"></canvas>

<!-- Countdown Overlay (must be outside any tabs!) -->
<div id="countdown-overlay"></div>

<!-- Scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<script src="../../scripts/app.js"></script>
<script src="../../scripts/config.js?v=2"></script>
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>

<script>
window.addEventListener("DOMContentLoaded", () => {
  const pinSection = document.getElementById("pin-section");
  const adminPinInput = document.getElementById("adminPin");
  const verifyPinBtn = document.getElementById("verifyPin");
  const pinMsg = document.getElementById("pinMsg");
  const tabsContainer = document.getElementById("tabs");
  const tabButtons = document.querySelectorAll(".tab-button");
  const tabContents = document.querySelectorAll(".tab-content");

  const qrId = document.getElementById("qrId");
  const qrLetter = document.getElementById("qrLetter");
  const generateBtn = document.getElementById("generate");
  const downloadBtn = document.getElementById("download");
  const qrcodeDiv = document.getElementById("qrcode");
  const msg = document.getElementById("msg");
  const mapTableBody = document.querySelector("#mapTable tbody");
  const exportBtn = document.getElementById("export");
  const exportMsg = document.getElementById("exportMsg");

  const tombolaCodesInput = document.getElementById("tombolaCodes");
  const startDrawBtn = document.getElementById("startDraw");
  const resetTombolaBtn = document.getElementById("resetTombola");
  const ticketList = document.getElementById("ticket-list");
  const winnerMsg = document.getElementById("winner-msg");
  const confettiCanvas = document.getElementById("confetti-canvas");
  const floatingOrbs = document.getElementById("floating-orbs");

  let qrMap = {};
  // Normalize stored codes to uppercase trimmed values
  // Handle both old string format and new {name, code} object format
  let registeredCodes = (JSON.parse(localStorage.getItem("tombolaCodes") || "[]") || []).map(c => {
    if (typeof c === 'string') {
      return { name: c.trim().toUpperCase(), code: c.trim().toUpperCase() };
    }
    return { name: c.name, code: c.code.trim().toUpperCase() };
  });

  // persisted winners and current round (0-based)
  let tombolaWinners = (JSON.parse(localStorage.getItem('tombolaWinners') || '[]') || []);
  let drawRound = parseInt(localStorage.getItem('tombolaRound') || '0', 10) || 0;

  renderTombolaCodes();
  updateStartButtonLabel();
  notifyOrbView();
  animateFloatingOrbs();
  renderPodium();
  
  // hide inlined ORBs until ORB View tab is active
  if (floatingOrbs) floatingOrbs.style.display = "none";

  // =====================
  // PIN verification
  // =====================
  verifyPinBtn.onclick = async () => {
    const pin = adminPinInput.value.trim();
    const daily = await generateDailyAdminPin();
    if (pin === daily) {
      pinSection.style.display = "none";
      tabsContainer.style.display = "block";
    } else {
      pinMsg.textContent = "⚠️ Invalid PIN.";
      pinMsg.style.color = "red";
    }
  };

  // =====================
  // Tab switching
  // =====================
  tabButtons.forEach(btn => {
    btn.onclick = () => {
      const target = btn.dataset.tab;
      tabContents.forEach(tab => tab.style.display = "none");
      tabContents.forEach(tab => tab.classList.remove("active"));
      document.getElementById(target).style.display = "block";
      document.getElementById(target).classList.add("active");
      tabButtons.forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      // Show ORBs only on ORB View tab
      if (target === "orbview-tab") {
        // switch to overlay mode so the ORB area centers and overlays the page
        floatingOrbs.classList.add('overlay');
        floatingOrbs.style.display = "block";
        // Re-render ORBs now the container is visible so placement uses real dimensions
        notifyOrbView();
      } else {
        floatingOrbs.classList.remove('overlay');
        floatingOrbs.style.display = "none";
      }
    };
  });

  // =====================
  // QR Generator
  // =====================
  let currentDataUrl = null;
  generateBtn.onclick = () => {
    const id = qrId.value.trim();
    const letter = qrLetter.value.trim();
    if (!id || !letter) { msg.textContent = "⚠️ Please enter both a code ID and letter."; return; }

    qrcodeDiv.innerHTML = "";
    const qrSize = Math.min(window.innerWidth * 0.8, 300);
    new QRCode(qrcodeDiv, { text: id, width: qrSize, height: qrSize });

    msg.textContent = `✅ QR code created for ${id} → ${letter}`;
    qrMap[id] = letter;
    renderTable();
    setTimeout(() => { const canvas = qrcodeDiv.querySelector("canvas"); if (canvas) currentDataUrl = canvas.toDataURL("image/png"); }, 500);
  };

  downloadBtn.onclick = () => {
    if (!currentDataUrl) { msg.textContent = "⚠️ Generate a QR code first."; return; }
    const id = qrId.value.trim() || "qr_code";
    const link = document.createElement("a");
    link.href = currentDataUrl;
    link.download = id + ".png";
    link.click();
  };

  function renderTable() {
    mapTableBody.innerHTML = "";
    Object.entries(qrMap).forEach(([id, letter]) => {
      const row = document.createElement("tr");
      row.innerHTML = `<td>${id}</td><td>${letter}</td>`;
      mapTableBody.appendChild(row);
    });
  }

  // Notify ORB view (inlined) to update
  function notifyOrbView() {
    // When ORB view is inlined, render directly
    const orbContainer = document.getElementById('orbview-tab').querySelector('#floating-orbs');
    if (orbContainer) {
      // If the container hasn't been laid out yet its clientWidth/height may be 0.
      // Defer to the next animation frame so the browser can apply layout after
      // switching to overlay/display: block. This ensures accurate placement.
      if ((orbContainer.clientWidth || orbContainer.clientHeight) === 0) {
        requestAnimationFrame(() => renderFloatingOrbsInContainer(orbContainer));
      } else {
        renderFloatingOrbsInContainer(orbContainer);
      }
    }
  }

  exportBtn.onclick = () => {
    if (Object.keys(qrMap).length === 0) { exportMsg.textContent = "⚠️ No mappings to export."; return; }
    const blob = new Blob([JSON.stringify(qrMap, null, 2)], { type: "application/json" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "qr-map.json";
    link.click();
    exportMsg.textContent = "✅ Mapping exported as qr-map.json";
  };


  // =====================
  // Tombola Draw
  // =====================
  function renderTombolaCodes() {
    tombolaCodesInput.value = registeredCodes.map(r => `${r.name} (${r.code})`).join("\n");
    ticketList.innerHTML = "";
    registeredCodes.forEach(reg => {
      const t = document.createElement("div");
      t.className = "ticket";
      t.textContent = reg.code;
      t.title = reg.name; // Add tooltip
      // mark if this code already won a place
      const win = tombolaWinners.find(w => w.code === reg.code);
      if (win) {
        t.classList.add('winner');
        t.dataset.place = win.place;
        t.title = `${reg.name} — ${win.placeLabel}`;
      }
      ticketList.appendChild(t);
    });
    notifyOrbView();
    renderPodium();
  }

  function updateStartButtonLabel() {
    if (!startDrawBtn) return;
    if (drawRound >= 3) {
      startDrawBtn.disabled = true;
      startDrawBtn.textContent = 'All places drawn';
      return;
    }
    const upcomingPlace = 3 - drawRound; // values: 3,2,1 across rounds
    const suffix = upcomingPlace === 1 ? 'st' : upcomingPlace === 2 ? 'nd' : 'rd';
    startDrawBtn.disabled = false;
    startDrawBtn.textContent = `Start Draw — ${upcomingPlace}${suffix} place`;
  }

  function renderFloatingOrbs() {
    // keep for backward-compat; do nothing when using inlined renderer
  }

  function renderFloatingOrbsInContainer(container) {
    container.innerHTML = "";
    const placedOrbs = [];
    const buffer = 20;
    // Compute available area for placement. If container hasn't been laid out yet
    // clientWidth/clientHeight may be 0 — fall back to a sensible default (900x900
    // or most of the viewport) so orbs don't all collapse to (0,0).
    const availableW = container.clientWidth || Math.min(window.innerWidth * 0.95, 900);
    const availableH = container.clientHeight || Math.min(window.innerHeight * 0.85, 900);
    registeredCodes.forEach(reg => {
      const orb = document.createElement("div");
      orb.className = "letter-box orb-dynamic";
      orb.textContent = reg.name; // Display name in the orb
      orb.dataset.code = reg.code; // Store code for winner identification
      orb.title = `${reg.name} (${reg.code})`; // Add tooltip with both name and code
      // random color (HSL) and readable text color
      const hue = Math.floor(Math.random() * 360);
      const sat = 60 + Math.floor(Math.random() * 21); // 60-80%
      const light = 40 + Math.floor(Math.random() * 21); // 40-60%
      orb.style.backgroundColor = `hsl(${hue}, ${sat}%, ${light}%)`;
      orb.style.color = (light > 60 ? '#000' : '#fff');

      // If this code already won in a previous round, mark as won so it
      // remains visually excluded and ignored by suspense/pulsing logic.
      const existingWin = tombolaWinners.find(w => w.code === reg.code);
      if (existingWin) {
        orb.classList.add('won', 'winner', 'glow');
        if (existingWin.color) orb.style.background = existingWin.color;
        orb.dataset.winnerColor = existingWin.color || '';
        orb.title = `${reg.name} — ${existingWin.placeLabel}`;
      }

      // Append hidden to measure its real size (text may make it wider than nominal)
      orb.style.visibility = 'hidden';
      // use transform for animation later; left/top are used only for measurement
      orb.style.left = '0px';
      orb.style.top = '0px';
      container.appendChild(orb);

      const orbW = Math.max(60, orb.offsetWidth);
      const orbH = Math.max(60, orb.offsetHeight);

      let tries = 0;
      let left, top, collides;
      do {
        left = Math.random() * Math.max(0, (availableW - orbW));
        top = Math.random() * Math.max(0, (availableH - orbH));
        const centerLeft = left + orbW / 2;
        const centerTop = top + orbH / 2;
        collides = placedOrbs.some(o => {
          const dx = o.centerLeft - centerLeft;
          const dy = o.centerTop - centerTop;
          return Math.sqrt(dx*dx + dy*dy) < (Math.max(o.w, orbW) + buffer);
        });
        tries++;
      } while (collides && tries < 300);

      // Position using transform so future animation uses GPU compositing.
      // Keep left/top at 0 so translate values are exact coordinates (avoid doubling).
      orb.style.left = `0px`;
      orb.style.top = `0px`;
      orb.style.visibility = 'visible';
      // initialize transform translate to the position and set internal position state
      orb._x = left; orb._y = top;
      orb.style.transform = `translate3d(${left}px, ${top}px, 0)`;
      // velocity state for smooth motion - increased range for more fluid movement
      orb._vx = (Math.random() - 0.5) * 2.5;
      orb._vy = (Math.random() - 0.5) * 2.5;
      placedOrbs.push({centerLeft: left + orbW / 2, centerTop: top + orbH / 2, w: orbW, h: orbH, el: orb});
    });
    // clear previous highlights
    const winnerMsgElem = document.querySelector('#orbview-tab #winner-msg');
    if (winnerMsgElem) winnerMsgElem.textContent = '';
    container.querySelectorAll('.letter-box').forEach(o => o.classList.remove('winner', 'glow'));
  }

  function renderPodium() {
    const podium = document.getElementById('podium');
    if (!podium) return;
    // Show up to 3 places (1,2,3) — map stored tombolaWinners by place
    podium.innerHTML = '';
    const places = [2, 1, 3]; // left-to-right: 2nd, 1st, 3rd
    places.forEach(p => {
      const placeObj = tombolaWinners.find(w => w.place === p);
      const div = document.createElement('div');
      div.className = `podium-place place${p}`;
      const orb = document.createElement('div');
      orb.className = 'podium-orb';
      if (placeObj) {
        const full = (placeObj.name || '').trim();
        // short form: First + initial of last name (e.g. "Bob D.") to help disambiguate
        let short = full;
        const parts = full.split(/\s+/).filter(Boolean);
        if (parts.length >= 2) {
          short = parts[0] + ' ' + parts[parts.length-1].charAt(0).toUpperCase() + '.';
        } else if (parts.length === 1) {
          short = parts[0];
        }
        orb.textContent = short;
        orb.title = full;
        if (placeObj.color) orb.style.background = placeObj.color;
      } else {
        orb.textContent = '';
        orb.style.background = 'linear-gradient(135deg,#eee,#ddd)';
      }
      const lbl = document.createElement('div');
      lbl.className = 'label';
      lbl.textContent = placeObj ? placeObj.placeLabel : '';
      div.appendChild(orb);
      div.appendChild(lbl);
      podium.appendChild(div);
    });
  }

  function animateFloatingOrbs() {
    const orbs = Array.from(document.querySelectorAll("#floating-orbs .letter-box:not(.winner)"));
    orbs.forEach(orb => {
      // If this orb is temporarily centered for suspense, don't animate it here
      if (orb._suspenseCentered) return;
      // ignore orbs moved to fixed positioning (winners)
      if (getComputedStyle(orb).position === 'fixed') return;
      
      // fall back to overlay size if parent isn't laid out yet
      const parentW = orb.parentElement.clientWidth || Math.min(window.innerWidth * 0.95, 900);
      const parentH = orb.parentElement.clientHeight || Math.min(window.innerHeight * 0.85, 900);
      
      // Initialize velocity if not set
      if (orb._vx === undefined) orb._vx = (Math.random() - 0.5) * 2.5;
      if (orb._vy === undefined) orb._vy = (Math.random() - 0.5) * 2.5;
      
      // Add gentle random drift like floating balloons
      orb._vx += (Math.random() - 0.5) * 0.5;
      orb._vy += (Math.random() - 0.5) * 0.5;
      
      // Apply lighter damping for more fluid movement
      orb._vx *= 0.985;
      orb._vy *= 0.985;
      
      // Keep velocities within reasonable bounds
      const maxSpeed = 3;
      orb._vx = Math.max(-maxSpeed, Math.min(maxSpeed, orb._vx));
      orb._vy = Math.max(-maxSpeed, Math.min(maxSpeed, orb._vy));
      
      // compute new position
      let x = (orb._x || 0) + orb._vx;
      let y = (orb._y || 0) + orb._vy;
      const orbW = orb.offsetWidth;
      const orbH = orb.offsetHeight;
      
      // Bounce off edges with some velocity reversal
      if (x <= 0) {
        x = 0;
        orb._vx = Math.abs(orb._vx) * 0.7;
      } else if (x >= parentW - orbW) {
        x = parentW - orbW;
        orb._vx = -Math.abs(orb._vx) * 0.7;
      }
      
      if (y <= 0) {
        y = 0;
        orb._vy = Math.abs(orb._vy) * 0.7;
      } else if (y >= parentH - orbH) {
        y = parentH - orbH;
        orb._vy = -Math.abs(orb._vy) * 0.7;
      }
      
      orb._x = x; orb._y = y;
      // apply transform - translate3d uses GPU compositing and avoids layout thrashing
      orb.style.transform = `translate3d(${x}px, ${y}px, 0)`;
    });
    requestAnimationFrame(animateFloatingOrbs);
  }

  function runConfetti() {
    const myConfetti = confetti.create(confettiCanvas, { resize: true });
    myConfetti({ particleCount: 200, spread: 70, origin: { y: 0.6 } });
    setTimeout(() => confettiCanvas.getContext('2d')?.clearRect(0,0,confettiCanvas.width,confettiCanvas.height), 5000);
  }

  function playFanfare() {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const now = ctx.currentTime;
      const freqs = [880, 1066, 1320]; // short arpeggio
      freqs.forEach((f, i) => {
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.frequency.value = f;
        o.connect(g);
        g.connect(ctx.destination);
        g.gain.setValueAtTime(0, now + i * 0.12);
        g.gain.linearRampToValueAtTime(0.15, now + i * 0.12 + 0.02);
        g.gain.linearRampToValueAtTime(0, now + i * 0.12 + 0.18);
        o.start(now + i * 0.12);
        o.stop(now + i * 0.12 + 0.2);
      });
    } catch (e) {
      console.log('Audio not available:', e);
    }
  }

  // Listen for storage updates so the ORB view refreshes when registrations
  // are added from other tabs/windows (e.g., registration page).
  window.addEventListener('storage', (ev) => {
    if (ev.key === 'tombolaCodes') {
      try {
        registeredCodes = (JSON.parse(ev.newValue || '[]') || []).map(c => {
          if (typeof c === 'string') {
            return { name: c.trim().toUpperCase(), code: c.trim().toUpperCase() };
          }
          return { name: c.name, code: c.code.trim().toUpperCase() };
        });
      } catch (e) {
        registeredCodes = [];
      }
      renderTombolaCodes();
      // If ORB tab is active, update it immediately
      const activeTab = document.querySelector('.tab-button.active')?.dataset.tab;
      if (activeTab === 'orbview-tab') notifyOrbView();
    }
  });

  // Extracted draw flow to avoid recursive event dispatch when switching tabs.
  function doStartDraw() {
    // main draw flow (ensures orbs are visible)
    if (startDrawBtn) startDrawBtn.disabled = true;
    try { localStorage.setItem('tombolaLocked', '1'); } catch(e) {}

    // filter out codes that have already won
    const available = registeredCodes.filter(r => !tombolaWinners.find(w => w.code === r.code));
    if (!available.length) {
      winnerMsg.textContent = "⚠️ No registered codes.";
      try { localStorage.removeItem('tombolaLocked'); } catch(e) {}
      if (startDrawBtn) startDrawBtn.disabled = false;
      return;
    }

    winnerMsg.textContent = 'Drawing... please wait';

    const orbs = Array.from(document.querySelectorAll('#floating-orbs .letter-box'));
    const suspensionDuration = 15000; // ms
    let startTime = Date.now();

    function clearSuspense() {
      orbs.forEach(o => o.classList.remove('suspense'));
    }

    function pulseCenterOrb(orb, duration = 300) {
      if (!orb || orb.classList.contains('centered')) return;
      const parent = orb.parentElement;
      const parentW = parent.clientWidth || Math.min(window.innerWidth * 0.95, 900);
      const parentH = parent.clientHeight || Math.min(window.innerHeight * 0.85, 900);
      const orbW = orb.offsetWidth;
      const orbH = orb.offsetHeight;

      const origX = orb._x || 0;
      const origY = orb._y || 0;

      const cx = (parentW) / 2 - (orbW / 2);
      const cy = (parentH) / 2 - (orbH / 2);

      orb._suspenseCentered = true;
      orb.classList.add('suspense-centered');
      orb._x = cx; orb._y = cy;
      orb._vx = 0; orb._vy = 0;
      orb.style.transform = `translate3d(${cx}px, ${cy}px, 0) scale(1.25)`;

      setTimeout(() => {
        if (orb.classList.contains('centered')) {
          orb._suspenseCentered = false;
          orb.classList.remove('suspense-centered');
          return;
        }
        orb._x = origX; orb._y = origY;
        orb._vx = (Math.random() - 0.5) * 1.2;
        orb._vy = (Math.random() - 0.5) * 1.2;
        orb.style.transform = `translate3d(${origX}px, ${origY}px, 0) scale(1)`;
        orb._suspenseCentered = false;
        orb.classList.remove('suspense-centered');
      }, duration + 40);
    }

    let sequentialActive = true;
    (async function sequentialPulseLoop() {
      const holdTime = 1600; // ms to hold each orb in center (calmer)
      const pauseBetween = 1000; // ms pause after release before next orb
      while (sequentialActive) {
        const elapsed = Date.now() - startTime;
        if (elapsed >= suspensionDuration) break;

        const candidates = orbs.filter(o => !o.classList.contains('centered') && !o._suspenseCentered && !o.classList.contains('won'));
        if (candidates.length === 0) {
          await new Promise(r => setTimeout(r, 300));
          continue;
        }

        const orb = candidates[Math.floor(Math.random() * candidates.length)];
        if (!orb) { await new Promise(r => setTimeout(r, 200)); continue; }

        orb.classList.add('suspense');
        pulseCenterOrb(orb, holdTime);
        await new Promise(r => setTimeout(r, holdTime + 80));
        orb.classList.remove('suspense');
        await new Promise(r => setTimeout(r, pauseBetween));
      }
      sequentialActive = false;
      clearSuspense();
      startCountdown();
    })();

    function startCountdown() {
      dramaticCountdown(() => {
        const availableNow = registeredCodes.filter(r => !tombolaWinners.find(w => w.code === r.code));
        if (!availableNow.length) {
          winnerMsg.textContent = '⚠️ No eligible candidates for this round.';
          try { localStorage.removeItem('tombolaLocked'); } catch (e) {}
          updateStartButtonLabel();
          return;
        }
        const choice = availableNow[Math.floor(Math.random() * availableNow.length)];
        revealWinner(choice.code, choice.name);
      });
    }

    function revealWinner(winnerCode, winnerName) {
      const orb = document.querySelector(`#floating-orbs .letter-box[data-code="${winnerCode}"]`);
      const placeNum = 3 - drawRound; // 3,2,1
      const suffix = placeNum === 1 ? 'st' : placeNum === 2 ? 'nd' : 'rd';
      const placeLabel = `${placeNum}${suffix} place`;

      let winnerColor = null;
      if (orb) {
        // capture computed background so podium can reuse the color
        winnerColor = getComputedStyle(orb).backgroundColor || orb.style.backgroundColor || null;
        orb.dataset.winnerColor = winnerColor;
        orb.classList.add('winner', 'glow', 'centered', 'won');
        // ensure it is ignored by suspense loop
        orb._suspenseCentered = false;
        // ensure visual emphasis: add a CSS class and a gentle pulse
        orb.animate([
          { transform: 'translate(-50%, -50%) scale(1.08)' },
          { transform: 'translate(-50%, -50%) scale(1.6)' }
        ], { duration: 600, easing: 'cubic-bezier(.2,.9,.2,1)' });
      }

      const winnerObj = { name: winnerName, code: winnerCode, place: placeNum, placeLabel, color: winnerColor };
      tombolaWinners.push(winnerObj);
      localStorage.setItem('tombolaWinners', JSON.stringify(tombolaWinners));
      drawRound = Math.min(3, drawRound + 1);
      localStorage.setItem('tombolaRound', String(drawRound));

      // Celebration: run confetti and fanfare audio for dramatic effect
      try { runConfetti(); } catch (e) { console.log('confetti failed', e); }
      try { playFanfare(); } catch (e) { console.log('fanfare failed', e); }

      renderTombolaCodes();
      renderPodium();
      setTimeout(() => {
        notifyOrbView();
        updateStartButtonLabel();
      }, 3500);
    }
  }

  // Safe Start Draw handler: ensure ORB tab active before starting
  if (startDrawBtn) {
    startDrawBtn.onclick = () => {
      const orbTabBtn = document.querySelector('.tab-button[data-tab="orbview-tab"]');
      const isOrbActive = orbTabBtn && orbTabBtn.classList.contains('active');
      if (orbTabBtn && !isOrbActive) {
        orbTabBtn.click();
        setTimeout(() => doStartDraw(), 120);
        return;
      }
      doStartDraw();
    };
  }

  resetTombolaBtn.onclick = async () => {
    const pin = prompt("Enter Admin PIN to reset Tombola:");
    const daily = await generateDailyAdminPin();
    if (pin !== daily) { alert("Invalid PIN. Cannot reset."); return; }
    registeredCodes = [];
    localStorage.setItem("tombolaCodes", JSON.stringify(registeredCodes));
    try { localStorage.removeItem('tombolaLocked'); } catch(e) {}
    // clear persisted winners and reset round
    tombolaWinners = [];
    localStorage.removeItem('tombolaWinners');
    drawRound = 0;
    localStorage.removeItem('tombolaRound');
    renderTombolaCodes();
      notifyOrbView();
      animateFloatingOrbs();
    // re-enable Start Draw after reset
    updateStartButtonLabel();
    winnerMsg.textContent = "";
  };
});

function dramaticCountdown(callback) {
  const overlay = document.getElementById("countdown-overlay");
  const numbers = [5, 4, 3, 2, 1];

  let idx = 0;

  function showNext() {
    if (idx >= numbers.length) {
      overlay.innerHTML = "";
      callback();  // continue with winner reveal
      return;
    }

    const num = numbers[idx];
    const el = document.createElement("div");
    el.className = "countdown-number";
    el.textContent = num;

    // Random start position
    const startX = Math.random() * window.innerWidth;
    const startY = Math.random() * window.innerHeight;
    el.style.left = startX + "px";
    el.style.top = startY + "px";

    overlay.appendChild(el);

    // Let browser place element THEN animate
    requestAnimationFrame(() => {
      el.style.opacity = "1";
      el.style.transform = "translate(-50%, -50%) scale(1)";
      el.style.left = "50%";
      el.style.top = "50%";
    });

    // Remove and move to next number
    setTimeout(() => {
      el.style.opacity = "0";
      el.style.transform += " scale(1.6)";

      setTimeout(() => {
        el.remove();
        idx++;
        showNext();
      }, 700);
    }, 900);
  }

  showNext();
}
</script>
</body>
</html>
