<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Scavenger Hunt â€“ Admin Panel</title>
<link rel="stylesheet" href="../../styles/styles.css">
<link rel="icon" type="image/png" href="../../favicon.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
/* ================================
   Admin PIN input - center aligned and uppercase
================================= */
body.admin #adminPin {
  text-align: center;
  text-transform: uppercase;
}

body.admin #adminPin::placeholder {
  text-transform: none;
}

/* ================================
   Tabs & Content
================================= */
#tabs { display: none; }

.tab-content { display: none; padding: 15px 0; }
.tab-content.active { display: block; }

/* Floating Orbs Layer - minimal inline rules (appearance controlled in styles.css) */
#floating-orbs {
  position: fixed;
  top: 50%;
  left: 50%;
  width: 400px;
  height: 300px;
  transform: translate(-50%, -50%);
  pointer-events: none;
  z-index: 9998;
  overflow: visible;
}

/* individual orb visuals (size, padding, shape) are defined in styles.css so they
   can adapt and scale to text; keep minimal positioning helpers here */
#floating-orbs .letter-box { position: absolute; transform-origin: center; }
#floating-orbs .letter-box.winner { z-index: 10001; }

/* Suspense-centering: when an orb is being highlighted during the draw
   it will briefly move toward the center, scale up, then return. We use
   translate/scale transitions so the animation stays on the compositor. */
#floating-orbs .letter-box.suspense-centered {
  transition: transform 260ms cubic-bezier(.2,.9,.2,1), box-shadow 260ms ease;
  z-index: 10000;
  box-shadow: 0 0 30px rgba(255,255,255,0.6);
}

/* Centered (final winner) tweaks - larger scale and a stronger z-index */
#floating-orbs .letter-box.centered {
  transition: transform 450ms cubic-bezier(.2,.9,.2,1), box-shadow 450ms ease;
  z-index: 10002 !important;
}

/* ================================
   Optional Glow Animation for Winner
================================= */
@keyframes winner-glow {
  0% { box-shadow: 0 0 10px #ffcc00; }
  50% { box-shadow: 0 0 25px #ffcc00; }
  100% { box-shadow: 0 0 10px #ffcc00; }
}

#floating-orbs .letter-box.winner.glow {
  animation: winner-glow 1s ease-in-out infinite alternate;
}

/* temporary suspense highlight used during draw countdown */
#floating-orbs .letter-box.suspense {
  box-shadow: 0 0 18px rgba(255,255,255,0.45);
  transform: scale(1.12);
}

/* ================================
   Pop animation (used for tickets/letters)
================================= */
@keyframes pop {
  0% { transform: scale(1); }
  50% { transform: scale(1.25); }
  100% { transform: scale(1); }
}

#countdown-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  pointer-events: none;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 99999;
}

.countdown-number {
  position: absolute;
  font-size: 8rem;
  font-weight: 900;
  color: white;
  text-shadow: 0 0 25px rgba(0,0,0,0.5);
  opacity: 0;
  transform: scale(0.3);
  transition: transform 0.9s ease, opacity 0.9s ease;
}

</style>
</head>

<body class="admin">
<script>
  if (sessionStorage.getItem("access") !== "granted") {
    window.location.href = "../../index.html";
  }
</script>
<main>
  <h2>Admin Panel</h2>
  <p>Secure access required to manage QR codes and run the Tombola.</p>

  <!-- PIN Entry -->
  <div id="pin-section">
    <input type="text" id="adminPin" placeholder="Enter Admin PIN">
    <div class="button-group">
      <button id="verifyPin">Verify</button>
    </div>
    <p id="pinMsg"></p>
  </div>


  <!-- Tabs -->
  <div id="tabs" class="tabs">
    <div class="button-group">
      <button class="tab-button active" data-tab="generator-tab">QR Generator</button>
      <button class="tab-button" data-tab="registration-tab">Registration</button>
      <button class="tab-button" data-tab="tombola-tab">Tombola Admin</button>
      <button class="tab-button" data-tab="orbview-tab">Tombola Draw</button>
    </div>

    <!-- Generator Tab -->
    <div id="generator-tab" class="tab-content active">
      <h3>QR Code Generator</h3>
      <label for="qrId">Enter Code ID (e.g. QR001):</label>
      <input id="qrId" type="text" placeholder="QR001">
      <p />
      <label for="qrLetter">Letter or Word:</label>
      <input id="qrLetter" type="text" placeholder="A">
      <div class="button-group">
        <button id="generate">Generate QR</button>
        <button id="download">Download QR</button>
      </div>
      <div id="qrcode"></div>
      <p id="msg"></p>
      <h3>Current Mappings (Session Only)</h3>
      <table id="mapTable">
        <thead><tr><th>QR Code</th><th>Letter</th></tr></thead>
        <tbody></tbody>
      </table>
      <div class="button-group">
        <button id="export">Export Mapping</button>
      </div>
      <p id="exportMsg"></p>
    </div>

    <!-- Registration Tab -->
    <div id="registration-tab" class="tab-content" style="text-align:center;display:none;">
      <h3>Player Registration</h3>
      <iframe src="../registration/registration.html" title="Player Registration" width="420" height="520" style="border: 1px solid #ccc; border-radius: 12px; box-shadow: 0 2px 12px rgba(0,0,0,0.07);"></iframe>
      <p style="font-size:0.95em;color:#888;margin-top:8px;">Players can register their code here.</p>
    </div>
      <!-- ORB View Tab -->
      <div id="orbview-tab" class="tab-content" style="text-align:center;display:none;">
        <p style="color:#888;font-size:0.95em;">Live view of all registered ORBs.</p>
        <div id="floating-orbs" class="orb-container"></div>
        <div class="button-group">
          <button id="startDraw">Start Draw</button>
        </div>
        <p id="winner-msg"></p>
      </div>

      <!-- Tombola Tab -->
      <div id="tombola-tab" class="tab-content">
        <h3>Tombola Draw</h3>
        <p>Registered Codes:</p>
        <textarea id="tombolaCodes" readonly></textarea>
        <div class="button-group">
          <button id="resetTombola">Reset Tombola</button>
        </div>
        <div id="ticket-list"></div>
      </div>
    </div>
  </div>
</main>

<!-- Confetti canvas -->
<canvas id="confetti-canvas"></canvas>

<!-- Countdown Overlay (must be outside any tabs!) -->
<div id="countdown-overlay"></div>

<!-- Scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<script src="../../scripts/app.js"></script>
<script src="../../scripts/config.js?v=2"></script>
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>

<script>
window.addEventListener("DOMContentLoaded", () => {
  const pinSection = document.getElementById("pin-section");
  const adminPinInput = document.getElementById("adminPin");
  const verifyPinBtn = document.getElementById("verifyPin");
  const pinMsg = document.getElementById("pinMsg");
  const tabsContainer = document.getElementById("tabs");
  const tabButtons = document.querySelectorAll(".tab-button");
  const tabContents = document.querySelectorAll(".tab-content");

  const qrId = document.getElementById("qrId");
  const qrLetter = document.getElementById("qrLetter");
  const generateBtn = document.getElementById("generate");
  const downloadBtn = document.getElementById("download");
  const qrcodeDiv = document.getElementById("qrcode");
  const msg = document.getElementById("msg");
  const mapTableBody = document.querySelector("#mapTable tbody");
  const exportBtn = document.getElementById("export");
  const exportMsg = document.getElementById("exportMsg");

  const tombolaCodesInput = document.getElementById("tombolaCodes");
  const startDrawBtn = document.getElementById("startDraw");
  const resetTombolaBtn = document.getElementById("resetTombola");
  const ticketList = document.getElementById("ticket-list");
  const winnerMsg = document.getElementById("winner-msg");
  const confettiCanvas = document.getElementById("confetti-canvas");
  const floatingOrbs = document.getElementById("floating-orbs");

  let qrMap = {};
  // Normalize stored codes to uppercase trimmed values
  // Handle both old string format and new {name, code} object format
  let registeredCodes = (JSON.parse(localStorage.getItem("tombolaCodes") || "[]") || []).map(c => {
    if (typeof c === 'string') {
      return { name: c.trim().toUpperCase(), code: c.trim().toUpperCase() };
    }
    return { name: c.name, code: c.code.trim().toUpperCase() };
  });

  renderTombolaCodes();
  notifyOrbView();
  animateFloatingOrbs();
  
  // hide inlined ORBs until ORB View tab is active
  if (floatingOrbs) floatingOrbs.style.display = "none";

  // =====================
  // PIN verification
  // =====================
  verifyPinBtn.onclick = async () => {
    const pin = adminPinInput.value.trim();
    const daily = await generateDailyAdminPin();
    if (pin === daily) {
      pinSection.style.display = "none";
      tabsContainer.style.display = "block";
    } else {
      pinMsg.textContent = "âš ï¸ Invalid PIN.";
      pinMsg.style.color = "red";
    }
  };

  // =====================
  // Tab switching
  // =====================
  tabButtons.forEach(btn => {
    btn.onclick = () => {
      const target = btn.dataset.tab;
      tabContents.forEach(tab => tab.style.display = "none");
      tabContents.forEach(tab => tab.classList.remove("active"));
      document.getElementById(target).style.display = "block";
      document.getElementById(target).classList.add("active");
      tabButtons.forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      // Show ORBs only on ORB View tab
      if (target === "orbview-tab") {
        // switch to overlay mode so the ORB area centers and overlays the page
        floatingOrbs.classList.add('overlay');
        floatingOrbs.style.display = "block";
        // Re-render ORBs now the container is visible so placement uses real dimensions
        notifyOrbView();
      } else {
        floatingOrbs.classList.remove('overlay');
        floatingOrbs.style.display = "none";
      }
    };
  });

  // =====================
  // QR Generator
  // =====================
  let currentDataUrl = null;
  generateBtn.onclick = () => {
    const id = qrId.value.trim();
    const letter = qrLetter.value.trim();
    if (!id || !letter) { msg.textContent = "âš ï¸ Please enter both a code ID and letter."; return; }

    qrcodeDiv.innerHTML = "";
    const qrSize = Math.min(window.innerWidth * 0.8, 300);
    new QRCode(qrcodeDiv, { text: id, width: qrSize, height: qrSize });

    msg.textContent = `âœ… QR code created for ${id} â†’ ${letter}`;
    qrMap[id] = letter;
    renderTable();
    setTimeout(() => { const canvas = qrcodeDiv.querySelector("canvas"); if (canvas) currentDataUrl = canvas.toDataURL("image/png"); }, 500);
  };

  downloadBtn.onclick = () => {
    if (!currentDataUrl) { msg.textContent = "âš ï¸ Generate a QR code first."; return; }
    const id = qrId.value.trim() || "qr_code";
    const link = document.createElement("a");
    link.href = currentDataUrl;
    link.download = id + ".png";
    link.click();
  };

  function renderTable() {
    mapTableBody.innerHTML = "";
    Object.entries(qrMap).forEach(([id, letter]) => {
      const row = document.createElement("tr");
      row.innerHTML = `<td>${id}</td><td>${letter}</td>`;
      mapTableBody.appendChild(row);
    });
  }

  // Notify ORB view (inlined) to update
  function notifyOrbView() {
    // When ORB view is inlined, render directly
    const orbContainer = document.getElementById('orbview-tab').querySelector('#floating-orbs');
    if (orbContainer) {
      // If the container hasn't been laid out yet its clientWidth/height may be 0.
      // Defer to the next animation frame so the browser can apply layout after
      // switching to overlay/display: block. This ensures accurate placement.
      if ((orbContainer.clientWidth || orbContainer.clientHeight) === 0) {
        requestAnimationFrame(() => renderFloatingOrbsInContainer(orbContainer));
      } else {
        renderFloatingOrbsInContainer(orbContainer);
      }
    }
  }

  exportBtn.onclick = () => {
    if (Object.keys(qrMap).length === 0) { exportMsg.textContent = "âš ï¸ No mappings to export."; return; }
    const blob = new Blob([JSON.stringify(qrMap, null, 2)], { type: "application/json" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "qr-map.json";
    link.click();
    exportMsg.textContent = "âœ… Mapping exported as qr-map.json";
  };


  // =====================
  // Tombola Draw
  // =====================
  function renderTombolaCodes() {
    tombolaCodesInput.value = registeredCodes.map(r => `${r.name} (${r.code})`).join("\n");
    ticketList.innerHTML = "";
    registeredCodes.forEach(reg => {
      const t = document.createElement("div");
      t.className = "ticket";
      t.textContent = reg.code;
      t.title = reg.name; // Add tooltip
      ticketList.appendChild(t);
    });
    notifyOrbView();
  }

  function renderFloatingOrbs() {
    // keep for backward-compat; do nothing when using inlined renderer
  }

  function renderFloatingOrbsInContainer(container) {
    container.innerHTML = "";
    const placedOrbs = [];
    const buffer = 20;
    // Compute available area for placement. If container hasn't been laid out yet
    // clientWidth/clientHeight may be 0 â€” fall back to a sensible default (900x900
    // or most of the viewport) so orbs don't all collapse to (0,0).
    const availableW = container.clientWidth || Math.min(window.innerWidth * 0.95, 900);
    const availableH = container.clientHeight || Math.min(window.innerHeight * 0.85, 900);
    registeredCodes.forEach(reg => {
      const orb = document.createElement("div");
      orb.className = "letter-box orb-dynamic";
      orb.textContent = reg.name; // Display name in the orb
      orb.dataset.code = reg.code; // Store code for winner identification
      orb.title = `${reg.name} (${reg.code})`; // Add tooltip with both name and code
      // random color (HSL) and readable text color
      const hue = Math.floor(Math.random() * 360);
      const sat = 60 + Math.floor(Math.random() * 21); // 60-80%
      const light = 40 + Math.floor(Math.random() * 21); // 40-60%
      orb.style.backgroundColor = `hsl(${hue}, ${sat}%, ${light}%)`;
      orb.style.color = (light > 60 ? '#000' : '#fff');

      // Append hidden to measure its real size (text may make it wider than nominal)
      orb.style.visibility = 'hidden';
      // use transform for animation later; left/top are used only for measurement
      orb.style.left = '0px';
      orb.style.top = '0px';
      container.appendChild(orb);

      const orbW = Math.max(60, orb.offsetWidth);
      const orbH = Math.max(60, orb.offsetHeight);

      let tries = 0;
      let left, top, collides;
      do {
        left = Math.random() * Math.max(0, (availableW - orbW));
        top = Math.random() * Math.max(0, (availableH - orbH));
        const centerLeft = left + orbW / 2;
        const centerTop = top + orbH / 2;
        collides = placedOrbs.some(o => {
          const dx = o.centerLeft - centerLeft;
          const dy = o.centerTop - centerTop;
          return Math.sqrt(dx*dx + dy*dy) < (Math.max(o.w, orbW) + buffer);
        });
        tries++;
      } while (collides && tries < 300);

      // Position using transform so future animation uses GPU compositing.
      // Keep left/top at 0 so translate values are exact coordinates (avoid doubling).
      orb.style.left = `0px`;
      orb.style.top = `0px`;
      orb.style.visibility = 'visible';
      // initialize transform translate to the position and set internal position state
      orb._x = left; orb._y = top;
      orb.style.transform = `translate3d(${left}px, ${top}px, 0)`;
      // velocity state for smooth motion - increased range for more fluid movement
      orb._vx = (Math.random() - 0.5) * 2.5;
      orb._vy = (Math.random() - 0.5) * 2.5;
      placedOrbs.push({centerLeft: left + orbW / 2, centerTop: top + orbH / 2, w: orbW, h: orbH, el: orb});
    });
    // clear previous highlights
    const winnerMsgElem = document.querySelector('#orbview-tab #winner-msg');
    if (winnerMsgElem) winnerMsgElem.textContent = '';
    container.querySelectorAll('.letter-box').forEach(o => o.classList.remove('winner', 'glow'));
  }

  function animateFloatingOrbs() {
    const orbs = Array.from(document.querySelectorAll("#floating-orbs .letter-box:not(.winner)"));
    orbs.forEach(orb => {
      // If this orb is temporarily centered for suspense, don't animate it here
      if (orb._suspenseCentered) return;
      // ignore orbs moved to fixed positioning (winners)
      if (getComputedStyle(orb).position === 'fixed') return;
      
      // fall back to overlay size if parent isn't laid out yet
      const parentW = orb.parentElement.clientWidth || Math.min(window.innerWidth * 0.95, 900);
      const parentH = orb.parentElement.clientHeight || Math.min(window.innerHeight * 0.85, 900);
      
      // Initialize velocity if not set
      if (orb._vx === undefined) orb._vx = (Math.random() - 0.5) * 2.5;
      if (orb._vy === undefined) orb._vy = (Math.random() - 0.5) * 2.5;
      
      // Add gentle random drift like floating balloons
      orb._vx += (Math.random() - 0.5) * 0.5;
      orb._vy += (Math.random() - 0.5) * 0.5;
      
      // Apply lighter damping for more fluid movement
      orb._vx *= 0.985;
      orb._vy *= 0.985;
      
      // Keep velocities within reasonable bounds
      const maxSpeed = 3;
      orb._vx = Math.max(-maxSpeed, Math.min(maxSpeed, orb._vx));
      orb._vy = Math.max(-maxSpeed, Math.min(maxSpeed, orb._vy));
      
      // compute new position
      let x = (orb._x || 0) + orb._vx;
      let y = (orb._y || 0) + orb._vy;
      const orbW = orb.offsetWidth;
      const orbH = orb.offsetHeight;
      
      // Bounce off edges with some velocity reversal
      if (x <= 0) {
        x = 0;
        orb._vx = Math.abs(orb._vx) * 0.7;
      } else if (x >= parentW - orbW) {
        x = parentW - orbW;
        orb._vx = -Math.abs(orb._vx) * 0.7;
      }
      
      if (y <= 0) {
        y = 0;
        orb._vy = Math.abs(orb._vy) * 0.7;
      } else if (y >= parentH - orbH) {
        y = parentH - orbH;
        orb._vy = -Math.abs(orb._vy) * 0.7;
      }
      
      orb._x = x; orb._y = y;
      // apply transform - translate3d uses GPU compositing and avoids layout thrashing
      orb.style.transform = `translate3d(${x}px, ${y}px, 0)`;
    });
    requestAnimationFrame(animateFloatingOrbs);
  }

  function runConfetti() {
    const myConfetti = confetti.create(confettiCanvas, { resize: true });
    myConfetti({ particleCount: 200, spread: 70, origin: { y: 0.6 } });
    setTimeout(() => confettiCanvas.getContext('2d')?.clearRect(0,0,confettiCanvas.width,confettiCanvas.height), 5000);
  }

  // Listen for storage updates so the ORB view refreshes when registrations
  // are added from other tabs/windows (e.g., registration page).
  window.addEventListener('storage', (ev) => {
    if (ev.key === 'tombolaCodes') {
      try {
        registeredCodes = (JSON.parse(ev.newValue || '[]') || []).map(c => {
          if (typeof c === 'string') {
            return { name: c.trim().toUpperCase(), code: c.trim().toUpperCase() };
          }
          return { name: c.name, code: c.code.trim().toUpperCase() };
        });
      } catch (e) {
        registeredCodes = [];
      }
      renderTombolaCodes();
      // If ORB tab is active, update it immediately
      const activeTab = document.querySelector('.tab-button.active')?.dataset.tab;
      if (activeTab === 'orbview-tab') notifyOrbView();
    }
  });

  startDrawBtn.onclick = () => {
    startDrawBtn.disabled = true;
    try { localStorage.setItem('tombolaLocked', '1'); } catch(e) {}

    if (!registeredCodes.length) {
      winnerMsg.textContent = "âš ï¸ No registered codes.";
      try { localStorage.removeItem('tombolaLocked'); } catch(e) {}
      if (startDrawBtn) startDrawBtn.disabled = false;
      return;
    }

    winnerMsg.textContent = 'Drawing... please wait';

    const orbs = Array.from(document.querySelectorAll('#floating-orbs .letter-box'));
    const suspensionDuration = 15000; // ms
    const tickInterval = 200; // ms highlight tick
    let tickTimer = null;
    let startTime = Date.now();

    function clearSuspense() {
      if (tickTimer) { clearInterval(tickTimer); tickTimer = null; }
      orbs.forEach(o => o.classList.remove('suspense'));
    }
    // Helper: smoothly move an orb toward the center and return it after delay
    function pulseCenterOrb(orb, duration = 300) {
      if (!orb || orb.classList.contains('centered')) return;
      const parent = orb.parentElement;
      const parentW = parent.clientWidth || Math.min(window.innerWidth * 0.95, 900);
      const parentH = parent.clientHeight || Math.min(window.innerHeight * 0.85, 900);
      const orbW = orb.offsetWidth;
      const orbH = orb.offsetHeight;

      // store current translate values
      const origX = orb._x || 0;
      const origY = orb._y || 0;

      const cx = (parentW) / 2 - (orbW / 2);
      const cy = (parentH) / 2 - (orbH / 2);

      // mark as suspended so the animator ignores it
      orb._suspenseCentered = true;
      orb.classList.add('suspense-centered');
      // move to center and scale slightly and update logical position
      orb._x = cx; orb._y = cy;
      orb._vx = 0; orb._vy = 0;
      orb.style.transform = `translate3d(${cx}px, ${cy}px, 0) scale(1.25)`;

      // after duration, restore original logical position and visual state
      setTimeout(() => {
        // if the orb became the final centered winner, leave it centered
        if (orb.classList.contains('centered')) {
          orb._suspenseCentered = false;
          orb.classList.remove('suspense-centered');
          return;
        }
        orb._x = origX; orb._y = origY;
        // restore a small random velocity so motion continues smoothly
        orb._vx = (Math.random() - 0.5) * 1.2;
        orb._vy = (Math.random() - 0.5) * 1.2;
        orb.style.transform = `translate3d(${origX}px, ${origY}px, 0) scale(1)`;
        orb._suspenseCentered = false;
        orb.classList.remove('suspense-centered');
      }, duration + 40);
    }

    tickTimer = setInterval(() => {
      const elapsed = Date.now() - startTime;
      if (elapsed >= suspensionDuration) { clearSuspense(); startCountdown(); return; }
      // clear previous suspense flags (visual highlights)
      orbs.forEach(o => o.classList.remove('suspense'));

      // pick 1-3 random orbs to briefly center and highlight
      const count = Math.max(1, Math.floor(Math.random() * Math.min(3, orbs.length)));
      const picked = new Set();
      for (let i = 0; i < count; i++) {
        let idx = Math.floor(Math.random() * orbs.length);
        // avoid duplicates in this tick
        let tries = 0;
        while (picked.has(idx) && tries++ < 6) idx = Math.floor(Math.random() * orbs.length);
        picked.add(idx);
        const orb = orbs[idx];
        if (!orb) continue;
        orb.classList.add('suspense');
        pulseCenterOrb(orb, tickInterval - 40);
      }
    }, tickInterval);

    function startCountdown() {
      dramaticCountdown(() => {
        const winner = registeredCodes[Math.floor(Math.random() * registeredCodes.length)];
        revealWinner(winner.code, winner.name);
      });
    }

    function revealWinner(winnerCode, winnerName) {
      // finalize
      winnerMsg.textContent = `ðŸŽ‰ Winner: ${winnerName} (${winnerCode})`;
      ticketList.querySelectorAll('.ticket').forEach(t => t.classList.remove('winner'));
      const winnerDiv = Array.from(ticketList.children).find(t => t.textContent.trim().toUpperCase() === String(winnerCode).trim().toUpperCase());
      if (winnerDiv) winnerDiv.classList.add('winner');

      const winnerOrb = Array.from(document.querySelectorAll('#floating-orbs .letter-box')).find(orb => orb.dataset.code === winnerCode);
      if (winnerOrb) {
        document.querySelectorAll('#floating-orbs .letter-box.centered').forEach(o => o.classList.remove('centered'));
        winnerOrb.classList.add('winner', 'glow', 'centered');
        const parent = winnerOrb.parentElement;
        const parentW = parent.clientWidth || Math.min(window.innerWidth * 0.95, 900);
        const parentH = parent.clientHeight || Math.min(window.innerHeight * 0.85, 900);
        const cx = (parentW) / 2 - (winnerOrb.offsetWidth / 2);
        const cy = (parentH) / 2 - (winnerOrb.offsetHeight / 2);
        winnerOrb._vx = 0; winnerOrb._vy = 0;
        winnerOrb.style.left = '0px'; winnerOrb.style.top = '0px';
        winnerOrb._x = cx; winnerOrb._y = cy;
        // Use centered class and explicit transform for scale so the orb grows smoothly
        winnerOrb.style.transform = `translate3d(${cx}px, ${cy}px, 0) scale(1.9)`;
      }

      runConfetti();
      clearSuspense();
      // keep the tombolaLocked flag in storage until admin presses Reset
      // do not re-enable Start Draw here â€” Reset will clear the lock and re-enable
    }
  };

  resetTombolaBtn.onclick = async () => {
    const pin = prompt("Enter Admin PIN to reset Tombola:");
    const daily = await generateDailyAdminPin();
    if (pin !== daily) { alert("Invalid PIN. Cannot reset."); return; }
    registeredCodes = [];
    localStorage.setItem("tombolaCodes", JSON.stringify(registeredCodes));
    try { localStorage.removeItem('tombolaLocked'); } catch(e) {}
    renderTombolaCodes();
      notifyOrbView();
      animateFloatingOrbs();
    // re-enable Start Draw after reset
    if (startDrawBtn) startDrawBtn.disabled = false;
    winnerMsg.textContent = "";
  };
});

function dramaticCountdown(callback) {
  const overlay = document.getElementById("countdown-overlay");
  const numbers = [5, 4, 3, 2, 1];

  let idx = 0;

  function showNext() {
    if (idx >= numbers.length) {
      overlay.innerHTML = "";
      callback();  // continue with winner reveal
      return;
    }

    const num = numbers[idx];
    const el = document.createElement("div");
    el.className = "countdown-number";
    el.textContent = num;

    // Random start position
    const startX = Math.random() * window.innerWidth;
    const startY = Math.random() * window.innerHeight;
    el.style.left = startX + "px";
    el.style.top = startY + "px";

    overlay.appendChild(el);

    // Let browser place element THEN animate
    requestAnimationFrame(() => {
      el.style.opacity = "1";
      el.style.transform = "translate(-50%, -50%) scale(1)";
      el.style.left = "50%";
      el.style.top = "50%";
    });

    // Remove and move to next number
    setTimeout(() => {
      el.style.opacity = "0";
      el.style.transform += " scale(1.6)";

      setTimeout(() => {
        el.remove();
        idx++;
        showNext();
      }, 700);
    }, 900);
  }

  showNext();
}
</script>
</body>
</html>
